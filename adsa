= AArrrraayy  <<  OObbjjeecctt

------------------------------------------------------------------------
= IInncclluuddeess::
Enumerable (from ruby core)

Diff::LCS (from gem diff-lcs-1.5.0)

(from ruby core)
------------------------------------------------------------------------
An Array is an ordered, integer-indexed collection of objects, called
_e_l_e_m_e_n_t_s.  Any object may be an Array element.

== AArrrraayy  IInnddeexxeess

Array indexing starts at 0, as in C or Java.

A positive index is an offset from the first element:
* Index 0 indicates the first element.
* Index 1 indicates the second element.
* ...

A negative index is an offset, backwards, from the end of the array:
* Index -1 indicates the last element.
* Index -2 indicates the next-to-last element.
* ...

A non-negative index is _i_n_ _r_a_n_g_e if it is smaller than
the size of the array.  For a 3-element array:
* Indexes 0 through 2 are in range.
* Index 3 is out of range.

A negative index is _i_n_ _r_a_n_g_e if its absolute value is
not larger than the size of the array.  For a 3-element array:
* Indexes -1 through -3 are in range.
* Index -4 is out of range.

== CCrreeaattiinngg  AArrrraayyss

A new array can be created by using the literal constructor [].  Arrays
can contain different types of objects.  For example, the array below
contains an Integer, a String and a Float:

  ary = [1, "two", 3.0] #=> [1, "two", 3.0]

An array can also be created by explicitly calling Array.new with zero,
one (the initial size of the Array) or two arguments (the initial size
and a default object).

  ary = Array.new    #=> []
  Array.new(3)       #=> [nil, nil, nil]
  Array.new(3, true) #=> [true, true, true]

Note that the second argument populates the array with references to the
same object.  Therefore, it is only recommended in cases when you need
to instantiate arrays with natively immutable objects such as Symbols,
numbers, true or false.

To create an array with separate objects a block can be passed instead.
This method is safe to use with mutable objects such as hashes, strings
or other arrays:

  Array.new(4) {Hash.new}    #=> [{}, {}, {}, {}]
  Array.new(4) {|i| i.to_s } #=> ["0", "1", "2", "3"]

This is also a quick way to build up multi-dimensional arrays:

  empty_table = Array.new(3) {Array.new(3)}
  #=> [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]

An array can also be created by using the Array() method, provided by
Kernel, which tries to call #to_ary, then #to_a on its argument.

  Array({:a => "a", :b => "b"}) #=> [[:a, "a"], [:b, "b"]]

== EExxaammppllee  UUssaaggee

In addition to the methods it mixes in through the Enumerable module,
the Array class has proprietary methods for accessing, searching and
otherwise manipulating arrays.

Some of the more common ones are illustrated below.

== AAcccceessssiinngg  EElleemmeennttss

Elements in an array can be retrieved using the Array#[] method.  It can
take a single integer argument (a numeric index), a pair of arguments
(start and length) or a range. Negative indices start counting from the
end, with -1 being the last element.

  arr = [1, 2, 3, 4, 5, 6]
  arr[2]    #=> 3
  arr[100]  #=> nil
  arr[-3]   #=> 4
  arr[2, 3] #=> [3, 4, 5]
  arr[1..4] #=> [2, 3, 4, 5]
  arr[1..-3] #=> [2, 3, 4]

Another way to access a particular array element is by using the #at
method

  arr.at(0) #=> 1

The #slice method works in an identical manner to Array#[].

To raise an error for indices outside of the array bounds or else to
provide a default value when that happens, you can use #fetch.

  arr = ['a', 'b', 'c', 'd', 'e', 'f']
  arr.fetch(100) #=> IndexError: index 100 outside of array bounds: -6...6
  arr.fetch(100, "oops") #=> "oops"

The special methods #first and #last will return the first and last
elements of an array, respectively.

  arr.first #=> 1
  arr.last  #=> 6

To return the first n elements of an array, use #take

  arr.take(3) #=> [1, 2, 3]

#drop does the opposite of #take, by returning the elements after n
elements have been dropped:

  arr.drop(3) #=> [4, 5, 6]

== OObbttaaiinniinngg  IInnffoorrmmaattiioonn  aabboouutt  aann  AArrrraayy

Arrays keep track of their own length at all times.  To query an array
about the number of elements it contains, use #length, #count or #size.

  browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
  browsers.length #=> 5
  browsers.count #=> 5

To check whether an array contains any elements at all

  browsers.empty? #=> false

To check whether a particular item is included in the array

  browsers.include?('Konqueror') #=> false

== AAddddiinngg  IItteemmss  ttoo  AArrrraayyss

Items can be added to the end of an array by using either #push or #<<

  arr = [1, 2, 3, 4]
  arr.push(5) #=> [1, 2, 3, 4, 5]
  arr << 6    #=> [1, 2, 3, 4, 5, 6]

#unshift will add a new item to the beginning of an array.

  arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]

With #insert you can add a new element to an array at any position.

  arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]

Using the #insert method, you can also insert multiple values at once:

  arr.insert(3, 'orange', 'pear', 'grapefruit')
  #=> [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]

== RReemmoovviinngg  IItteemmss  ffrroomm  aann  AArrrraayy

The method #pop removes the last element in an array and returns it:

  arr =  [1, 2, 3, 4, 5, 6]
  arr.pop #=> 6
  arr #=> [1, 2, 3, 4, 5]

To retrieve and at the same time remove the first item, use #shift:

  arr.shift #=> 1
  arr #=> [2, 3, 4, 5]

To delete an element at a particular index:

  arr.delete_at(2) #=> 4
  arr #=> [2, 3, 5]

To delete a particular element anywhere in an array, use #delete:

  arr = [1, 2, 2, 3]
  arr.delete(2) #=> 2
  arr #=> [1,3]

A useful method if you need to remove nil values from an array is
#compact:

  arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
  arr.compact  #=> ['foo', 0, 'bar', 7, 'baz']
  arr          #=> ['foo', 0, nil, 'bar', 7, 'baz', nil]
  arr.compact! #=> ['foo', 0, 'bar', 7, 'baz']
  arr          #=> ['foo', 0, 'bar', 7, 'baz']

Another common need is to remove duplicate elements from an array.

It has the non-destructive #uniq, and destructive method #uniq!

  arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
  arr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]

== IItteerraattiinngg  oovveerr  AArrrraayyss

Like all classes that include the Enumerable module, Array has an each
method, which defines what elements should be iterated over and how.  In
case of Array's #each, all elements in the Array instance are yielded to
the supplied block in sequence.

Note that this operation leaves the array unchanged.

  arr = [1, 2, 3, 4, 5]
  arr.each {|a| print a -= 10, " "}
  # prints: -9 -8 -7 -6 -5
  #=> [1, 2, 3, 4, 5]

Another sometimes useful iterator is #reverse_each which will iterate
over the elements in the array in reverse order.

  words = %w[first second third fourth fifth sixth]
  str = ""
  words.reverse_each {|word| str += "#{word} "}
  p str #=> "sixth fifth fourth third second first "

The #map method can be used to create a new array based on the original
array, but with the values modified by the supplied block:

  arr.map {|a| 2*a}     #=> [2, 4, 6, 8, 10]
  arr                   #=> [1, 2, 3, 4, 5]
  arr.map! {|a| a**2}   #=> [1, 4, 9, 16, 25]
  arr                   #=> [1, 4, 9, 16, 25]

== SSeelleeccttiinngg  IItteemmss  ffrroomm  aann  AArrrraayy

Elements can be selected from an array according to criteria defined in
a block.  The selection can happen in a destructive or a non-destructive
manner.  While the destructive operations will modify the array they
were called on, the non-destructive methods usually return a new array
with the selected elements, but leave the original array unchanged.

=== NNoonn--ddeessttrruuccttiivvee  SSeelleeccttiioonn

  arr = [1, 2, 3, 4, 5, 6]
  arr.select {|a| a > 3}       #=> [4, 5, 6]
  arr.reject {|a| a < 3}       #=> [3, 4, 5, 6]
  arr.drop_while {|a| a < 4}   #=> [4, 5, 6]
  arr                          #=> [1, 2, 3, 4, 5, 6]

=== DDeessttrruuccttiivvee  SSeelleeccttiioonn

#select! and #reject! are the corresponding destructive methods to
#select and #reject

Similar to #select vs. #reject, #delete_if and #keep_if have the exact
opposite result when supplied with the same block:

  arr.delete_if {|a| a < 4}   #=> [4, 5, 6]
  arr                         #=> [4, 5, 6]

  arr = [1, 2, 3, 4, 5, 6]
  arr.keep_if {|a| a < 4}   #=> [1, 2, 3]
  arr                       #=> [1, 2, 3]






for pack.c
------------------------------------------------------------------------
= CCllaassss  mmeetthhooddss::

  [], new, try_convert

= IInnssttaannccee  mmeetthhooddss::

  &, *, +, -, <<, <=>, ==, [], []=, abbrev, all?, any?, append, assoc,
  at, bsearch, bsearch_index, clear, collect, collect!, combination,
  compact, compact!, concat, count, cycle, deconstruct, delete,
  delete_at, delete_if, difference, dig, drop, drop_while, each,
  each_index, empty?, eql?, fetch, fill, filter, filter!, find_index,
  first, flatten, flatten!, hash, include?, index, initialize_copy,
  insert, inspect, intersection, join, keep_if, last, length, map, map!,
  max, min, minmax, none?, one?, pack, permutation, pop, prepend,
  product, push, rassoc, reject, reject!, repeated_combination,
  repeated_permutation, replace, reverse, reverse!, reverse_each,
  rindex, rotate, rotate!, sample, select, select!, shelljoin, shift,
  shuffle, shuffle!, size, slice, slice!, sort, sort!, sort_by!, sum,
  take, take_while, to_a, to_ary, to_h, to_s, transpose, union, uniq,
  uniq!, unshift, values_at, zip, |

(from gem activesupport-7.0.1)
------------------------------------------------------------------------











------------------------------------------------------------------------
= CCllaassss  mmeetthhooddss::

  wrap

= IInnssttaannccee  mmeetthhooddss::

  deep_dup, excluding, extract!, extract_options!, fifth, forty_two,
  fourth, from, in_groups, in_groups_of, including, inquiry, second,
  second_to_last, split, third, third_to_last, to, to_formatted_s,
  to_fs, to_param, to_query, to_sentence, to_xml, without

(from gem concurrent-ruby-1.1.9)
------------------------------------------------------------------------
@!macro concurrent_array
------------------------------------------------------------------------
------------------------------------------------------------------------
Also found in:
  gem diff-lcs-1.5.0

